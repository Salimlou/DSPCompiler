I am working on AlephOne, and though I am not quite ready to open source the whole project, there are bits of it that are definitely appropriate for being open sourced because getting compatibility among developers is a major issue right now when dealing with MIDI.  Now that I am working on a custom sound engine that deals very directly with my special MIDI variant, I am hoping to get some help from other developers that use vDSP routinely.   So here's a compiler to generate vDSP kernels that is written in Python so that it is easy to change.

Apple's vDSP is a library from the Accelerate.Framework that lets you write data parallel code (ie: vector computing).  It is essentially an assembly language called from a C library where userspace arrays are treated as giant registers in which every element in the array is synchronously computed at the same time.  Projects like OpenCL and CUDA exist specifically because of this problem, though OpenCL isn't quite yet available on iOS yet (and therefore on older devices).  The principles are similar whether the parallelism comes from running on a GPU or from using vector instructions on the main processor.

This is the beginnings of a project to handle vDSP code in a reasonable way.  It is a Python compiler that generates the C snippets that would be very hard to maintain if vDSP code is written directly.  It takes as input a variant of LISP, so that it is trivial to write the compiler and write additions and optimizers to it as the need arises.  

The main problem I have with vDSP is when I am translating a function from my inner loop that was written by iterating per sample, the code turns inside out.  You end up writing something that looks like what the compiler would have generated (like OpenCL and CUDA kernels).  For example, the original code might look like:

	//Compute something over a loop
	//There could be a lot of statements in here at some point
	for(int i=0;i<length;i++)
	{
		float a = b[i] * c[i];
		d[i] = 1 - a[i];
	}

	#define INPARALLEL(statement,length) { for(int i=0; i<length; i++) { statement } }

	INPARALLEL(a[i]  = b[i],length)
	INPARALLEL(a[i] *= c[i],length)
	INPARALLEL(d[i]  = 1,length)
	INPARALLEL(d[i] -= a[i],length)

Which roughly translates to how it gets done with calls to vDSP:

	xDSP_vcp(b,a,length);
	vDSP_vmul(c,1, a,1, a,1, length);
	vDSP_vsfill(d,1, &one, length);
	vDSP_vsub(d,1, a,1, d,1, length);

So, the lack of clarity and the task of allocating an optimal number of temporary "registers" as code changes can make this kind of code hard to maintain.  A LISP syntax custom language trivial to make a compiler for, and Python is a reasonable language for tasks which require a lot of symbolic manipulation, and it is very widely available and well known.  Here is a snippet of some vDSP generated by the original LISP code in comments:

	( do
		(vset output  (vadd (vmul w0 w1) (vsmul w2 w3)))
		(vset output1 (vadd a (vmul x (vadd y0 y1))))
		(vset output2 (vadd c (vmul output1 (vsadd y2 sy3))))
		(out output2)
	)

LISP is more of a family of languages based around this trivial syntax.  Its main benefit is that it is a direct representation of the syntax tree, and it is easy to treat it as a data structure.  With a small Python based compiler for it, adding in support for some of the more specialized vDSP functions and writing optimizers to avoid redundant work is really quite easy.
 
When run through the compiler, it generates this:


	/*
	(do
		(vset output  (vadd (vmul w0 w1) (vsmul w2 w3)))
		(vset output1 (vadd a (vmul x (vadd y0 y1))))
		(vset output2 (vadd c (vmul output1 (vsadd y2 sy3))))
	)
	*/
	vDSP_vmul(w0,1,w1,1,accumulator0,1,length);
	vDSP_vsvsmul(w2,1,&w3,accumulator1,1,length);
	vDSP_vadd(accumulator0,1,accumulator1,1,output,1,length);
	vDSP_vadd(y0,1,y1,1,accumulator4,1,length);
	vDSP_vmul(x,1,accumulator4,1,accumulator5,1,length);
	vDSP_vadd(a,1,accumulator5,1,output1,1,length);
	vDSP_vsvsadd(y2,1,&sy3,accumulator8,1,length);
	vDSP_vmul(output1,1,accumulator8,1,accumulator9,1,length);
	vDSP_vadd(c,1,accumulator9,1,output2,1,length);
 
